/**
 * Security Middleware
 * Implements authentication, rate limiting, and security headers
 */

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

// Security headers configuration
const securityHeaders = {
  // Prevent clickjacking attacks
  'X-Frame-Options': 'DENY',

  // Prevent MIME type sniffing
  'X-Content-Type-Options': 'nosniff',

  // Control referrer information
  'Referrer-Policy': 'strict-origin-when-cross-origin',

  // Enforce HTTPS
  'Strict-Transport-Security': 'max-age=31536000; includeSubDomains; preload',

  // XSS Protection (legacy browsers)
  'X-XSS-Protection': '1; mode=block',

  // Control browser features
  'Permissions-Policy': 'camera=(), microphone=(), geolocation=(), payment=(self)',

  // Content Security Policy
  'Content-Security-Policy': [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.googletagmanager.com https://connect.facebook.net",
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: https: blob:",
    "font-src 'self' data:",
    "connect-src 'self' https://api.stripe.com https://www.google-analytics.com https://analytics.google.com",
    "frame-src 'self' https://js.stripe.com https://hooks.stripe.com",
    "frame-ancestors 'none'",
    "base-uri 'self'",
    "form-action 'self'",
    "upgrade-insecure-requests"
  ].join('; ')
};

// CORS configuration
const corsHeaders = {
  'Access-Control-Allow-Origin': process.env.NEXT_PUBLIC_APP_URL || '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
  'Access-Control-Max-Age': '86400',
};

// Rate limiting storage (use Redis in production)
const requestCounts = new Map<string, { count: number; resetTime: number }>();

// Clean up old rate limit entries
// setInterval(() => {
//   const now = Date.now();
//   const keysToDelete: string[] = [];

//   requestCounts.forEach((value, key) => {
//     if (now > value.resetTime) {
//       keysToDelete.push(key);
//     }
//   });

//   keysToDelete.forEach(key => {
//     requestCounts.delete(key);
//   });
// }, 60000); // Clean every minute - DISABLED for dev

function getRateLimitKey(request: NextRequest): string {
  const forwarded = request.headers.get('x-forwarded-for');
  const ip = forwarded ? forwarded.split(',')[0] : 'unknown';
  const pathname = request.nextUrl.pathname;
  return `${ip}:${pathname}`;
}

async function checkRateLimit(
  request: NextRequest,
  limit: number = 60,
  window: number = 60000
): Promise<{ allowed: boolean; remaining: number; reset: number }> {
  const key = getRateLimitKey(request);
  const now = Date.now();

  const record = requestCounts.get(key);

  if (!record || now > record.resetTime) {
    requestCounts.set(key, {
      count: 1,
      resetTime: now + window
    });
    return { allowed: true, remaining: limit - 1, reset: now + window };
  }

  if (record.count >= limit) {
    return { allowed: false, remaining: 0, reset: record.resetTime };
  }

  record.count++;
  requestCounts.set(key, record);

  return {
    allowed: true,
    remaining: limit - record.count,
    reset: record.resetTime
  };
}

// Protected API routes configuration
const protectedRoutes = [
  '/api/admin',
  '/api/dashboard',
  '/api/user'
];

// Public API routes with stricter rate limits
const strictRateLimitRoutes = {
  '/api/create-payment-intent': { limit: 5, window: 60000 },
  '/api/send-confirmation-email': { limit: 10, window: 60000 },
  '/api/webhooks/stripe': { limit: 100, window: 60000 },
};

export async function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname;

  // Skip middleware for static assets
  if (
    pathname.startsWith('/_next') ||
    pathname.startsWith('/static') ||
    pathname.includes('.') // Files with extensions
  ) {
    return NextResponse.next();
  }

  // Create response with security headers
  const response = NextResponse.next();

  // Apply security headers
  Object.entries(securityHeaders).forEach(([key, value]) => {
    response.headers.set(key, value);
  });

  // Handle CORS for API routes
  if (pathname.startsWith('/api')) {
    // Apply CORS headers
    Object.entries(corsHeaders).forEach(([key, value]) => {
      response.headers.set(key, value);
    });

    // Handle preflight requests
    if (request.method === 'OPTIONS') {
      return new NextResponse(null, { status: 200, headers: response.headers });
    }

    // Check for strict rate limit routes
    for (const [route, config] of Object.entries(strictRateLimitRoutes)) {
      if (pathname.startsWith(route)) {
        const rateLimitResult = await checkRateLimit(request, config.limit, config.window);

        if (!rateLimitResult.allowed) {
          return new NextResponse(
            JSON.stringify({
              error: 'Too many requests. Please try again later.',
              retryAfter: Math.ceil((rateLimitResult.reset - Date.now()) / 1000)
            }),
            {
              status: 429,
              headers: {
                'Content-Type': 'application/json',
                'X-RateLimit-Limit': config.limit.toString(),
                'X-RateLimit-Remaining': '0',
                'X-RateLimit-Reset': new Date(rateLimitResult.reset).toISOString(),
                'Retry-After': Math.ceil((rateLimitResult.reset - Date.now()) / 1000).toString()
              }
            }
          );
        }

        // Add rate limit headers to successful responses
        response.headers.set('X-RateLimit-Limit', config.limit.toString());
        response.headers.set('X-RateLimit-Remaining', rateLimitResult.remaining.toString());
        response.headers.set('X-RateLimit-Reset', new Date(rateLimitResult.reset).toISOString());
      }
    }

    // Default rate limiting for other API routes
    if (!Object.keys(strictRateLimitRoutes).some(route => pathname.startsWith(route))) {
      const rateLimitResult = await checkRateLimit(request, 60, 60000);

      if (!rateLimitResult.allowed) {
        return new NextResponse(
          JSON.stringify({
            error: 'Too many requests. Please try again later.'
          }),
          {
            status: 429,
            headers: {
              'Content-Type': 'application/json',
              'Retry-After': Math.ceil((rateLimitResult.reset - Date.now()) / 1000).toString()
            }
          }
        );
      }
    }

    // Check authentication for protected routes
    for (const route of protectedRoutes) {
      if (pathname.startsWith(route)) {
        const authHeader = request.headers.get('authorization');

        if (!authHeader || !authHeader.startsWith('Bearer ')) {
          return new NextResponse(
            JSON.stringify({ error: 'Authentication required' }),
            {
              status: 401,
              headers: {
                'Content-Type': 'application/json',
                'WWW-Authenticate': 'Bearer'
              }
            }
          );
        }

        // TODO: Implement actual token verification
        // const token = authHeader.substring(7);
        // const isValid = await verifyToken(token);
        // if (!isValid) {
        //   return new NextResponse(
        //     JSON.stringify({ error: 'Invalid token' }),
        //     { status: 401 }
        //   );
        // }
      }
    }
  }

  // Log security events (implement proper logging in production)
  if (process.env.NODE_ENV === 'production') {
    // Log request for security monitoring
    console.log({
      timestamp: new Date().toISOString(),
      method: request.method,
      path: pathname,
      ip: request.headers.get('x-forwarded-for') || 'unknown',
      userAgent: request.headers.get('user-agent')
    });
  }

  return response;
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
};